#! /usr/bin/python
import yacc         # herramienta para construir el parser (PLY)
import sys, Nodo, funciones
from melonlex import tokens         # tokens de melon

# tabla de precedencia
precedence = (
       ('left','OR'),
       ('left','AND'),        
       ('right', 'NOT'),
       ('nonassoc', 'MENOR', 'MAYOR','MENOROIGUAL','MAYOROIGUAL','DISTINTO','IGUAL'),
       ('left', 'MAS','MENOS'),
       ('left', 'PRODUCTO', 'COCIENTE'),
       ('right', 'DDOSPUNTOS'),                
       ('right', 'UMENOS'),        
       ('left', 'APLICA'),
)

def p_e_t(p):
	'e : t'
	p[0] = Nodo.Nodo('no_terminal',p[1])
def p_e_constante(p):
	't : c'
	p[0] = Nodo.Nodo('no_terminal',p[1])
def p_e_variable(p):
	't : v'
	p[0] = Nodo.Nodo('no_terminal',p[1])
def p_entero(p):
	'c : ENTERO'
	p[0] = Nodo.Nodo('CONSTANTE',Nodo.Nodo('ENTERO',p[1]))
def p_false(p):
	'c : FALSE'
	p[0] = Nodo.Nodo('CONSTANTE',Nodo.Nodo('BOOLEANO','FALSE'))
def p_true(p):
	'c : TRUE'
	p[0] = Nodo.Nodo('CONSTANTE',Nodo.Nodo('BOOLEANO','TRUE'))
def p_listavacia(p):
	'c : CORCHETEI CORCHETED'
	p[0] = Nodo.Nodo('CONSTLV',Nodo.Nodo('','LISTAVACIA'))
def p_variable(p):
	'v : VARIABLE'
	p[0] = Nodo.Nodo('no_terminal',Nodo.Nodo('VARIABLE',p[1]))
def p_aplicar(p):
	't : t t %prec APLICA'
	p[0] = Nodo.Nodo('APLICAR',p[1],p[2])
def p_sumar(p):
	'e : e MAS e'
	p[0] = Nodo.Nodo('MAS',p[1],p[3])
def p_restar(p):
	'e : e MENOS e'
	p[0] = Nodo.Nodo('MENOS',p[1],p[3])
def p_neg(p):
	'e : MENOS e %prec UMENOS'
	p[0] = Nodo.Nodo('NEGATIVO',p[2])
def p_multiplicar(p):
	'e : e PRODUCTO e'
	p[0] = Nodo.Nodo('PRODUCTO',p[1],p[3])
def p_dividir(p):
	'e : e COCIENTE e'
	p[0] = Nodo.Nodo('COCIENTE',p[1],p[3])
def p_parentesis(p):
	't : PARENTESISI e PARENTESISD'
	p[0] = Nodo.Nodo('no_terminal',Nodo.Nodo('',p[2]))
def p_menor(p):
	'e : e MENOR e'
	p[0] = Nodo.Nodo('MENOR',p[1],p[3])
def p_menoroigual(p):
	'e : e MENOROIGUAL e'
	p[0] = Nodo.Nodo('MENOROIGUAL',p[1],p[3])
def p_mayor(p):
	'e : e MAYOR e'
	p[0] = Nodo.Nodo('MAYOR',p[1],p[3])
def p_mayoroigual(p):
	'e : e MAYOROIGUAL e'
	p[0] = Nodo.Nodo('MAYOROIGUAL',p[1],p[3])
def p_igual(p):
	'e : e IGUAL e'
	p[0] = Nodo.Nodo('IGUAL',p[1],p[3])
def p_distinto(p):
	'e : e DISTINTO e'
	p[0] = Nodo.Nodo('DISTINTO',p[1],p[3])
def p_not(p):
	'e : NOT e '
	p[0] = Nodo.Nodo('NO',p[2])
def p_or(p):
	'e : e OR e'
	p[0] = Nodo.Nodo('OR',p[1],p[3])
def p_lista(p):
	'e : e DDOSPUNTOS e'
	p[0] = Nodo.Nodo('LISTA',p[1],p[3])
def p_and(p):
	'e : e AND e'
	p[0] = Nodo.Nodo('AND',p[1],p[3])
def p_if(p):
	'e : IF e THEN e ELSE e FI'
	p[0] = Nodo.Nodo('IF',Nodo.Nodo("sub",p[2],p[4]),p[6])
def p_p_constante(p):
	'patron : c'
	p[0] = Nodo.Nodo('PATRON',p[1])
def p_p_variable(p):
	'patron : v'
	p[0] = Nodo.Nodo('PATRON',p[1])
def p_p_Listap1(p):
	'Listapatron : patron'
	p[0] = Nodo.Nodo('lp',p[1])
def p_p_Listap(p):
	'Listapatron : Listapatron patron'
	p[0] = Nodo.Nodo('lp',p[1],p[2])
def p_p_parentesis(p):
	'patron : PARENTESISI patron PARENTESISD'
	p[0] = Nodo.Nodo('PATRON',p[2]) 
def p_let(p):
	'e : LET patron IGUAL e IN e TEL'
	p[0] = Nodo.Nodo('LET',Nodo.Nodo("sub",p[2],p[4]),p[6])
def p_fun(p):
	'e : FUN arg NUF'
	p[0] = Nodo.Nodo('FUN',p[2])
	dicc = funciones.recorrer_fun(p[0],{},0)
	if not (funciones.iguales(dicc.values())): p_error(0)
	dicc ={}
def p_arg(p):
	'arg : arg PIPE arg2'
	p[0] = Nodo.Nodo('arg2',p[1],p[3])
def p_arg_2(p):
	'arg : arg2'
	p[0] = Nodo.Nodo('arg2',p[1])
def p_arg2(p):
	'arg2 : Listapatron FLECHA e'
	p[0] = Nodo.Nodo('arg2',Nodo.Nodo('LISTAPATRON',p[1]),p[3])

def p_p_dospuntos(p):
	'patron : patron DDOSPUNTOS patron'
	p[0] = Nodo.Nodo('PATRON',Nodo.Nodo('LISTA',p[1],p[3]))

# Manejo de errores
def p_error(p):
	print "Error Sintactico"
	sys.exit(-1)

# Valor de constantes, variables, etc
def valor(nodo):
	# Fin de recursion
	if nodo.type == 'ENTERO' or nodo.type == 'VARIABLE' or nodo.type == 'BOOLEANO':
		return nodo
	if nodo.type == 'no_terminal':
		return valor(nodo.izquierdo)

# Match
def match(nodo1,nodo2):

	# Fin de recursion
	if (not isinstance(nodo1,Nodo.Nodo)) and (not isinstance(nodo2,Nodo.Nodo)):
		print '- ',nodo1,'\n- ',nodo2
		return nodo1 == nodo2

	# Bajar si el nodo es no_terminal
	if nodo1.type == 'no_terminal' or nodo1.type == '': return match(nodo1.izquierdo,nodo2)
	if nodo2.type == 'no_terminal' or nodo2.type == '': return match(nodo2.izquierdo,nodo1)

	# Variables hacen match con todo
	if nodo1.type == 'VARIABLE' or nodo2.type == 'VARIABLE':
		print '- Variable\n -'
		return True

	# Constantes
	if nodo1.type == 'CONSTANTE' and nodo2.type == 'CONSTANTE':
		print '- Constante\n -'
		print '(',nodo1.type,' ',nodo2.type,')\n'
		return match(nodo1.izquierdo.izquierdo,nodo2.izquierdo.izquierdo)

	# Entero
	if nodo1.type == 'ENTERO' and nodo2.type == 'ENTERO':
		print '- Entero\n -'
		return match(nodo1.izquierdo,nodo2.izquierdo)

	# Booleano
	if nodo1.type == 'BOOLEANO' and nodo2.type == 'BOOLEANO':
		print '- Booleano\n -'
		return match(nodo1.izquierdo,nodo2.izquierdo)

	# Listavacia
	if nodo1.type == 'CONSTLV' and nodo2.type == 'CONSTLV':
		return match(nodo1.izquierdo,nodo2.izquierdo)

	# Listas
	if nodo1.type == 'LISTA' and nodo2.type == 'LISTA':
		print 'BLAH'
		return match(nodo1.izquierdo,nodo2.izquierdo) and  match(nodo1.derecho,nodo2.derecho)

	return False


# inicializacion de variables para contar tamano de las Listapatron
dicc = {}
num_dicc = 0
cont_patrones = 0
cont_dicc = 0

# construccion del parser
melonparser = yacc.yacc()


### PRUEBAS MATCH
#p = '(5::(2)::x) (5::2::3)'
#prueba = melonparser.parse(p, tracking=True)
#print prueba
#uno = prueba.izquierdo.izquierdo.izquierdo.izquierdo
#dos = prueba.izquierdo.derecho.izquierdo.izquierdo
#print prueba, ' ', isinstance(prueba,Nodo.Nodo)
#print '\nRESULTADO\n',uno.type,'\n',dos.type,'\n', match(uno,dos)

# se recibe el codigo en MeLon
try:
	s = sys.stdin.read()
except EOFError:
	pass #break
#if not s: continue
result = melonparser.parse(s, tracking=True)	# parseo de la entrada
if not (funciones.revisar_patrones(dicc)):
	#print dicc
	p_error(0)
print result	# arbol

# se resetean valores para calcular el tamano de las
# Listapatron del nuevo codigo de entrada
dicc = {}
cont_patrones = 0
#num_dicc = 0
